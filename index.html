<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>dots.</title>

  <!-- Favicon: white dot -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='white'/></svg>">

  <!-- Open Graph -->
  <meta property="og:title" content="dots.">
  <meta property="og:image" content="/preview.png">
  <meta property="og:type" content="website">

  <!-- Twitter / X -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="dots.">
  <meta name="twitter:image" content="/preview.png">
  <style>
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #000;
      overflow: hidden;
      height: 100vh;
      height: 100dvh;
      width: 100vw;
      cursor: crosshair;
      transition: background 0.6s ease;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    body.light {
      background: #f0f0f0;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      touch-action: none;
    }
    .buttons {
      position: fixed;
      bottom: 28px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 10;
    }
    .buttons a, .ctrl-btn {
      color: #fff;
      text-decoration: none;
      font-family: 'Courier New', Courier, monospace;
      font-size: 12px;
      letter-spacing: 1px;
      transition: opacity 0.3s ease, color 0.6s ease;
      opacity: 0.6;
      -webkit-tap-highlight-color: transparent;
    }
    .buttons a:hover, .ctrl-btn:hover {
      opacity: 1;
    }
    .controls {
      position: fixed;
      bottom: 28px;
      right: 30px;
      z-index: 10;
      display: flex;
      gap: 18px;
    }
    .ctrl-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 0;
    }
    body.light .buttons a,
    body.light .ctrl-btn {
      color: #111;
    }
    @media (max-width: 600px) {
      .buttons {
        bottom: 18px;
        gap: 14px;
      }
      .buttons a, .ctrl-btn {
        font-size: 11px;
      }
      .controls {
        bottom: 18px;
        right: 16px;
        gap: 12px;
      }
    }
  </style>
</head>
<body>

  <div class="buttons">
    <a href="https://denizeffects.com/" target="_blank">[MY WEBSITE]</a>
    <a href="https://x.com/denizeffects" target="_blank">[X]</a>
  </div>

  <div class="controls">
    <button class="ctrl-btn" id="shapeToggle">[CUBE]</button>
    <button class="ctrl-btn" id="themeToggle">[LIGHT]</button>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ─── Device detection ─────────────────────────────────
    const isMobile = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent)
      || (navigator.maxTouchPoints > 1);

    // ─── Theme state ──────────────────────────────────────
    let isDark = true;
    let themeT = 1.0;
    const themeBtn = document.getElementById('themeToggle');

    themeBtn.addEventListener('click', () => {
      isDark = !isDark;
      themeBtn.textContent = isDark ? '[LIGHT]' : '[DARK]';
      document.body.classList.toggle('light', !isDark);
    });

    // ─── Scene ────────────────────────────────────────────
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      200
    );
    camera.position.z = 9;

    const renderer = new THREE.WebGLRenderer({
      antialias: !isMobile,
      powerPreference: isMobile ? 'low-power' : 'high-performance',
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
    renderer.setClearColor(0x000000, 1);
    document.body.prepend(renderer.domElement);

    // ─── Background refraction shader ─────────────────────
    const bgVert = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const bgFrag = `
      precision ${ isMobile ? 'mediump' : 'highp' } float;

      uniform float uTime;
      uniform vec2  uMouse;
      uniform vec2  uResolution;
      uniform float uTheme;

      varying vec2 vUv;

      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
      }

      float noise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        f = f * f * (3.0 - 2.0 * f);
        return mix(
          mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
          mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),
          f.y
        );
      }

      float fbm(vec2 p) {
        float v = 0.0, a = 0.5;
        mat2 r = mat2(0.8, 0.6, -0.6, 0.8);
        for (int i = 0; i < ${ isMobile ? 4 : 6 }; i++) {
          v += a * noise(p);
          p = r * p * 2.0;
          a *= 0.5;
        }
        return v;
      }

      void main() {
        float aspect = uResolution.x / uResolution.y;
        vec2 p = (vUv - 0.5) * vec2(aspect, 1.0);

        vec2 mOff = uMouse * 0.06;

        float n1 = fbm(p * 1.6 + uTime * 0.055 + mOff);
        float n2 = fbm(p * 2.8 - uTime * 0.04 + mOff * 0.5 + 8.0);
        float n3 = fbm(p * 0.9 + uTime * 0.03 - mOff * 0.3 + 3.0);

        float wave = p.x + 0.12;
        wave += sin(p.y * 3.2 + uTime * 0.12 + n1 * 1.8) * 0.14;
        wave += cos(p.y * 1.8 - uTime * 0.08 + n3 * 1.2) * 0.08;
        wave += n1 * 0.22;

        float bw = 9.0;
        float b_cyan   = exp(-(wave - 0.16) * (wave - 0.16) * bw);
        float b_teal   = exp(-(wave - 0.08) * (wave - 0.08) * bw);
        float b_orange = exp(-(wave + 0.02) * (wave + 0.02) * bw);
        float b_red    = exp(-(wave + 0.10) * (wave + 0.10) * bw);
        float b_mag    = exp(-(wave + 0.18) * (wave + 0.18) * bw);

        vec3 col = vec3(0.0);
        col += vec3(0.08, 0.88, 1.00) * b_cyan;
        col += vec3(0.10, 0.80, 0.60) * b_teal;
        col += vec3(1.00, 0.68, 0.10) * b_orange;
        col += vec3(1.00, 0.15, 0.20) * b_red;
        col += vec3(0.70, 0.06, 0.58) * b_mag;

        col *= 0.45 + 0.2 * n2;

        float vig = 1.0 - length(p) * 0.5;
        vig = clamp(vig, 0.0, 1.0);
        vig = vig * vig;
        col *= vig;

        vec3 darkBg  = vec3(0.002, 0.002, 0.005);
        vec3 lightBg = vec3(0.935, 0.93, 0.925);
        vec3 darkResult = darkBg + col * 0.3;

        vec3 lightCol = vec3(0.0);
        lightCol += vec3(0.45, 0.85, 0.92) * b_cyan;
        lightCol += vec3(0.50, 0.82, 0.70) * b_teal;
        lightCol += vec3(0.95, 0.75, 0.40) * b_orange;
        lightCol += vec3(0.92, 0.45, 0.45) * b_red;
        lightCol += vec3(0.75, 0.40, 0.72) * b_mag;
        lightCol *= 0.45 + 0.2 * n2;
        lightCol *= vig;

        float intensity = clamp(length(lightCol) * 0.7, 0.0, 1.0);
        vec3 lightResult = mix(lightBg, lightCol * 0.95 + 0.35, intensity * 0.35);
        lightResult += (n1 - 0.5) * 0.015;

        vec3 final = mix(lightResult, darkResult, uTheme);
        gl_FragColor = vec4(final, 1.0);
      }
    `;

    const bgUniforms = {
      uTime:       { value: 0 },
      uMouse:      { value: new THREE.Vector2(0, 0) },
      uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
      uTheme:      { value: 1.0 },
    };

    const bgMat = new THREE.ShaderMaterial({
      vertexShader: bgVert,
      fragmentShader: bgFrag,
      uniforms: bgUniforms,
      depthWrite: false,
      depthTest: false,
    });

    const bgMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), bgMat);
    bgMesh.frustumCulled = false;

    const bgScene  = new THREE.Scene();
    const bgCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    bgScene.add(bgMesh);

    // ─── Dot textures ─────────────────────────────────────
    function makeDotTexture(color) {
      const s = isMobile ? 32 : 64;
      const c = document.createElement('canvas');
      c.width = s; c.height = s;
      const ctx = c.getContext('2d');
      ctx.beginPath();
      ctx.arc(s / 2, s / 2, s / 2 - 2, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      const t = new THREE.CanvasTexture(c);
      t.needsUpdate = true;
      return t;
    }
    const whiteDotTex = makeDotTexture('#ffffff');
    const darkDotTex  = makeDotTexture('#1a1a1a');

    // ─── Shape generation ──────────────────────────────────
    const PARTICLE_COUNT = isMobile ? 4000 : 7000;
    const RADIUS = 3.0;
    const CUBE_HALF = 2.0;

    // Globe — fibonacci sphere
    const globeLocal = new Float32Array(PARTICLE_COUNT * 3);
    const goldenAngle = Math.PI * (3 - Math.sqrt(5));
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const y = 1 - (i / (PARTICLE_COUNT - 1)) * 2;
      const r = Math.sqrt(1 - y * y);
      const th = goldenAngle * i;
      globeLocal[i * 3]     = Math.cos(th) * r * RADIUS;
      globeLocal[i * 3 + 1] = y * RADIUS;
      globeLocal[i * 3 + 2] = Math.sin(th) * r * RADIUS;
    }

    // Cube — structured grid on 6 faces
    const cubeLocal = new Float32Array(PARTICLE_COUNT * 3);
    const GRID = isMobile ? 26 : 35;
    let ci = 0;
    for (let face = 0; face < 6 && ci < PARTICLE_COUNT; face++) {
      for (let i = 0; i < GRID && ci < PARTICLE_COUNT; i++) {
        for (let j = 0; j < GRID && ci < PARTICLE_COUNT; j++) {
          const u = ((i + 0.5) / GRID - 0.5) * 2 * CUBE_HALF;
          const v = ((j + 0.5) / GRID - 0.5) * 2 * CUBE_HALF;
          const i3 = ci * 3;
          switch (face) {
            case 0: cubeLocal[i3]=u; cubeLocal[i3+1]=v; cubeLocal[i3+2]= CUBE_HALF; break;
            case 1: cubeLocal[i3]=u; cubeLocal[i3+1]=v; cubeLocal[i3+2]=-CUBE_HALF; break;
            case 2: cubeLocal[i3]= CUBE_HALF; cubeLocal[i3+1]=u; cubeLocal[i3+2]=v; break;
            case 3: cubeLocal[i3]=-CUBE_HALF; cubeLocal[i3+1]=u; cubeLocal[i3+2]=v; break;
            case 4: cubeLocal[i3]=u; cubeLocal[i3+1]= CUBE_HALF; cubeLocal[i3+2]=v; break;
            case 5: cubeLocal[i3]=u; cubeLocal[i3+1]=-CUBE_HALF; cubeLocal[i3+2]=v; break;
          }
          ci++;
        }
      }
    }

    // Shape state
    let isGlobe = true;
    const shapeBtn = document.getElementById('shapeToggle');
    const origLocal = new Float32Array(globeLocal);

    shapeBtn.addEventListener('click', () => {
      isGlobe = !isGlobe;
      shapeBtn.textContent = isGlobe ? '[CUBE]' : '[GLOBE]';
      origLocal.set(isGlobe ? globeLocal : cubeLocal);
    });

    const N = PARTICLE_COUNT;
    const homePos = new Float32Array(N * 3);
    const curPos  = new Float32Array(globeLocal);
    const vel     = new Float32Array(N * 3);

    const globeGeo = new THREE.BufferGeometry();
    globeGeo.setAttribute('position', new THREE.BufferAttribute(curPos, 3));

    const globeMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: isMobile ? 0.07 : 0.055,
      sizeAttenuation: true,
      map: whiteDotTex,
      transparent: true,
      alphaTest: 0.4,
      depthWrite: false,
    });

    const globePoints = new THREE.Points(globeGeo, globeMat);
    scene.add(globePoints);

    const rotMatrix = new THREE.Matrix4();
    const euler     = new THREE.Euler(0, 0, 0, 'XYZ');
    const tempVec   = new THREE.Vector3();

    // ─── Background stars ─────────────────────────────────
    const STARS = isMobile ? 120 : 250;
    const starArr = new Float32Array(STARS * 3);
    for (let i = 0; i < STARS; i++) {
      starArr[i * 3]     = (Math.random() - 0.5) * 50;
      starArr[i * 3 + 1] = (Math.random() - 0.5) * 35;
      starArr[i * 3 + 2] = -Math.random() * 40 - 5;
    }
    const starGeo = new THREE.BufferGeometry();
    starGeo.setAttribute('position', new THREE.BufferAttribute(starArr, 3));
    const starMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.09,
      sizeAttenuation: true,
      map: whiteDotTex,
      transparent: true,
      alphaTest: 0.2,
      opacity: 0.55,
      depthWrite: false,
    });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // ─── Input tracking (mouse + touch) ───────────────────
    const mouseNDC = new THREE.Vector2(9999, 9999);
    const smoothMouse = new THREE.Vector2(0, 0);
    let mouseActive = false;

    function setPointer(x, y) {
      mouseNDC.x =  (x / window.innerWidth)  * 2 - 1;
      mouseNDC.y = -(y / window.innerHeight) * 2 + 1;
      mouseActive = true;
    }
    function clearPointer() {
      mouseActive = false;
      mouseNDC.set(9999, 9999);
    }

    // Mouse
    document.addEventListener('mousemove', (e) => setPointer(e.clientX, e.clientY));
    document.addEventListener('mouseleave', clearPointer);

    // Touch
    document.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      setPointer(t.clientX, t.clientY);
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      setPointer(t.clientX, t.clientY);
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      e.preventDefault();
      clearPointer();
    }, { passive: false });

    document.addEventListener('touchcancel', clearPointer);

    // ─── Raycaster ────────────────────────────────────────
    const raycaster     = new THREE.Raycaster();
    const iPlane        = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    const hitPt         = new THREE.Vector3();
    const mouse3D       = new THREE.Vector3(9999, 9999, 9999);
    const mouse3DTarget = new THREE.Vector3(9999, 9999, 9999);

    // ─── Resize ───────────────────────────────────────────
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      bgUniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
    });

    // ─── Animation loop ──────────────────────────────────
    let prev = performance.now();
    let rotX = 0, rotY = 0;
    let elapsed = 0;

    renderer.autoClear = false;

    // Pre-compute constants outside loop
    const DAMP        = 0.85;
    const REP_STR     = 350.0;
    const REP_INNER   = 1.5;
    const CUTOFF_SQ   = 3.5 * 3.5;
    const MIN_DIST    = 0.4;
    const MAX_VEL     = 2.5;
    const RETURN_LERP = 0.045;
    const INV_REP_SQ  = 1 / (REP_INNER * REP_INNER);

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const dt  = Math.min((now - prev) / 1000, 0.05);
      prev = now;
      elapsed += dt;

      // ── Theme transition ──
      const targetT = isDark ? 1.0 : 0.0;
      themeT += (targetT - themeT) * 0.04;
      bgUniforms.uTheme.value = themeT;

      const inLight = themeT < 0.5;
      globeMat.map = inLight ? darkDotTex : whiteDotTex;
      globeMat.color.setHex(inLight ? 0x1a1a1a : 0xffffff);
      starMat.map = inLight ? darkDotTex : whiteDotTex;
      starMat.color.setHex(inLight ? 0x333333 : 0xffffff);
      starMat.opacity = inLight ? 0.35 : 0.55;

      // ── Smooth mouse for bg shader ──
      if (mouseActive) {
        smoothMouse.x += (mouseNDC.x - smoothMouse.x) * 0.04;
        smoothMouse.y += (mouseNDC.y - smoothMouse.y) * 0.04;
      } else {
        smoothMouse.x += (0 - smoothMouse.x) * 0.02;
        smoothMouse.y += (0 - smoothMouse.y) * 0.02;
      }

      bgUniforms.uTime.value = elapsed;
      bgUniforms.uMouse.value.copy(smoothMouse);

      // ── Rotation ──
      rotX += 0.12 * dt;
      rotY += 0.20 * dt;
      euler.set(rotX, rotY, 0);
      rotMatrix.makeRotationFromEuler(euler);

      // ── Home positions ──
      for (let i = 0; i < N; i++) {
        const i3 = i * 3;
        tempVec.set(origLocal[i3], origLocal[i3 + 1], origLocal[i3 + 2]);
        tempVec.applyMatrix4(rotMatrix);
        homePos[i3]     = tempVec.x;
        homePos[i3 + 1] = tempVec.y;
        homePos[i3 + 2] = tempVec.z;
      }

      // ── Star parallax ──
      if (mouseActive) {
        stars.position.x += (mouseNDC.x * 0.4 - stars.position.x) * 0.02;
        stars.position.y += (mouseNDC.y * 0.3 - stars.position.y) * 0.02;
      }

      // ── Pointer → world space ──
      if (mouseActive) {
        raycaster.setFromCamera(mouseNDC, camera);
        const hit = raycaster.ray.intersectPlane(iPlane, hitPt);
        if (hit) mouse3DTarget.copy(hitPt);
      } else {
        mouse3DTarget.set(9999, 9999, 9999);
      }
      mouse3D.lerp(mouse3DTarget, 0.15);

      // ── Particle physics ──
      const posArr = globeGeo.getAttribute('position').array;
      const mx = mouse3D.x, my = mouse3D.y, mz = mouse3D.z;

      for (let i = 0; i < N; i++) {
        const i3 = i * 3;

        const cx = posArr[i3];
        const cy = posArr[i3 + 1];
        const cz = posArr[i3 + 2];

        const dx = cx - mx;
        const dy = cy - my;
        const dz = cz - mz;
        const distSq = dx * dx + dy * dy + dz * dz;

        if (mouseActive && distSq > 0.000001 && distSq < CUTOFF_SQ) {
          const dist    = Math.sqrt(distSq);
          const effDist = dist > MIN_DIST ? dist : MIN_DIST;
          const force   = REP_STR * Math.exp(-distSq * INV_REP_SQ);
          const invD    = 1 / effDist;
          const fdt     = force * dt;
          vel[i3]     += dx * invD * fdt;
          vel[i3 + 1] += dy * invD * fdt;
          vel[i3 + 2] += dz * invD * fdt;
        }

        vel[i3]     *= DAMP;
        vel[i3 + 1] *= DAMP;
        vel[i3 + 2] *= DAMP;

        let vx = vel[i3], vy = vel[i3 + 1], vz = vel[i3 + 2];
        if (vx >  MAX_VEL) vx =  MAX_VEL; else if (vx < -MAX_VEL) vx = -MAX_VEL;
        if (vy >  MAX_VEL) vy =  MAX_VEL; else if (vy < -MAX_VEL) vy = -MAX_VEL;
        if (vz >  MAX_VEL) vz =  MAX_VEL; else if (vz < -MAX_VEL) vz = -MAX_VEL;
        vel[i3] = vx; vel[i3 + 1] = vy; vel[i3 + 2] = vz;

        let nx = cx + vx;
        let ny = cy + vy;
        let nz = cz + vz;

        nx += (homePos[i3]     - nx) * RETURN_LERP;
        ny += (homePos[i3 + 1] - ny) * RETURN_LERP;
        nz += (homePos[i3 + 2] - nz) * RETURN_LERP;

        posArr[i3]     = nx;
        posArr[i3 + 1] = ny;
        posArr[i3 + 2] = nz;
      }

      globeGeo.getAttribute('position').needsUpdate = true;

      renderer.clear();
      renderer.render(bgScene, bgCamera);
      renderer.clearDepth();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
